<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
    <script src="https://js.leapmotion.com/leap-0.6.4.js"></script>
    <script src="//js.leapmotion.com/leap-plugins-0.1.12.js"></script>
    <script src="//js.leapmotion.com/leap-widgets-0.1.0.js"></script>
		<script>
      'use strict';

      Leap.loop()
      .use('boneHand', {
        targetEl: document.body,
        opacity: 0.8
      })
      .use('proximity');

      // var scene = new THREE.Scene();
      // var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

      var scene = Leap.loopController.plugins.boneHand.scene;
      var camera = Leap.loopController.plugins.boneHand.camera;
      var renderer = Leap.loopController.plugins.boneHand.renderer;

      // Add a plane
      var planeGeo = new THREE.PlaneGeometry(0.1, 0.2);
      var material = new THREE.MeshPhongMaterial();
      var buttonMesh = new THREE.Mesh(planeGeo, material);
      // buttonMesh.name = "rectangular button";
      // Circular button:
      var circleGeo = new THREE.CircleGeometry(0.1, 32);
      buttonMesh = new THREE.Mesh(circleGeo, material.clone());
      buttonMesh.name = "round button";
      buttonMesh.position.set(-0.12, 0.1, -0.1);
      scene.add(buttonMesh);
      var roundButton = new PushButton(
        // for now, constructing with moveX and moveY turned off so that doesn't try and watch for XY intersections,
        // which won't work for circles.
        // todo - have a setter for moveX and moveY, so that proximities can be turned on and off.
        // Note that we have to bind press and release effects to each individual button. This is a long way from CSS rules still.
        new InteractablePlane(buttonMesh, Leap.loopController, {moveX: false, moveY: false})
      ).on('press', function(mesh){
        mesh.material.color.setHex(0xccccff);
      }).on('release', function(mesh){
        mesh.material.color.setHex(0xeeeeee);
      });

      // var renderer = new THREE.WebGLRenderer();
      // renderer.setSize( window.innerWidth, window.innerHeight );
      // document.body.appendChild( renderer.domElement );
      //
      // camera.position.z = 5;
      //
      // var render = function () {
      //   requestAnimationFrame( render );
      //   renderer.render(scene, camera);
      // };
      //
      // render();


		</script>
	</body>
</html>
